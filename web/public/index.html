<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Console</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fira Code', monospace;
            background-color: #111827;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1F2937; }
        ::-webkit-scrollbar-thumb { background: #4B5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6B7280; }
        .console-output-line { white-space: pre-wrap; word-break: break-all; }
        #start-modal-backdrop.hidden, #console-container.hidden { display: none; }
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
    </style>
</head>
<body class="text-gray-200 antialiased">

    <!-- Start Session Modal -->
    <div id="start-modal-backdrop" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 transition-opacity duration-300">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl transform scale-95 transition-transform duration-300 w-full max-w-md">
            <!-- Initial State -->
            <div id="modal-initial-state">
                <h2 class="text-2xl font-bold mb-4 text-white">Start New Console Session</h2>
                <p class="text-gray-400 mb-6">Select a container type and press Start to spin up a new instance</p>
                <div class="mb-6">
                    <label for="container-type-select" class="block text-sm font-medium text-gray-300 mb-2 text-left">GMod Branch</label>
                    <select id="container-type-select" class="block w-full bg-gray-700 border border-gray-600 text-white rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="public">Public</option>
                        <option value="sixty-four">64-bit</option>
                        <option value="prerelease">Prerelease</option>
                        <option value="dev">Dev</option>
                    </select>
                </div>
                <button id="start-session-button" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-8 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-400 disabled:bg-gray-500 disabled:cursor-wait">
                    Start
                </button>
            </div>
            <!-- Loading State -->
            <div id="modal-loading-state" class="hidden">
                <svg class="animate-spin h-8 w-8 text-indigo-400 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <h2 class="text-xl font-bold mb-2 text-white">Getting your environment set up...</h2>
                <p class="text-gray-400">The container is starting. This may take a few moments.</p>
            </div>
        </div>
    </div>

    <!-- Main Console UI -->
    <div id="console-container" class="hidden fixed inset-0 flex flex-col p-4 bg-gray-900">
        <div id="output-container" class="flex-grow overflow-y-auto overflow-x-hidden"></div>
        <div class="mt-4 flex items-center border-t border-gray-700 pt-3">
            <span class="text-green-400 mr-2 shrink-0">&gt;</span>
            <input type="text" id="command-input" class="w-full bg-transparent border-none focus:ring-0 text-gray-200 placeholder-gray-500" placeholder="Enter command..." autocomplete="off" autofocus disabled>
        </div>
    </div>

    <script type="module">
        class AnsiParser {
            static ansiColorMap = { "30":"text-black","31":"text-red-500","32":"text-green-500","33":"text-yellow-500","34":"text-blue-500","35":"text-purple-500","36":"text-cyan-500","37":"text-white","90":"text-gray-400","91":"text-red-400","92":"text-green-400","93":"text-yellow-400","94":"text-blue-400","95":"text-purple-400","96":"text-cyan-400","97":"text-gray-200","40":"bg-black","41":"bg-red-500","42":"bg-green-500","43":"bg-yellow-500","44":"bg-blue-500","45":"bg-purple-500","46":"bg-cyan-500","47":"bg-white", "1":"font-bold" };
            static parse(text) { const ansiRegex = /\u001b\[([0-9;]*?)m/g; let lastIndex = 0; let result = []; let match; while ((match = ansiRegex.exec(text)) !== null) { const plainText = text.substring(lastIndex, match.index); if (plainText) { result.push({ text: plainText, classes: [] }); } const codes = match[1].split(';').filter(code => code !== ""); if (codes.length === 0 || codes[0] === "0") { result.push({ text: "", classes: ["reset"] }); } else { const classes = codes.map(code => AnsiParser.ansiColorMap[code] || ""); result.push({ text: "", classes }); } lastIndex = ansiRegex.lastIndex; } const remainingText = text.substring(lastIndex); if (remainingText) { result.push({ text: remainingText, classes: [] }); } return result; }
        }

        class VirtualConsole {
            constructor(containerId, maxLines = 5000) { this.container = document.getElementById(containerId); this.maxLines = maxLines; this.lines = []; this.isAtBottom = true; this.container.addEventListener('scroll', () => { const scrollThreshold = 5; this.isAtBottom = this.container.scrollHeight - this.container.scrollTop - this.container.clientHeight < scrollThreshold; }); }
            addLine(lineContent) { this.addLines([lineContent]); }
            addLines(newLines) { if (!newLines || newLines.length === 0 || (newLines.length === 1 && !newLines[0])) return; const fragment = document.createDocumentFragment(); for (const line of newLines) { const lineElement = this.createLineElement(line); fragment.appendChild(lineElement); this.lines.push(lineElement); } this.container.appendChild(fragment); this.trimOldLines(); this.scrollToBottomIfNeeded(); }
            createLineElement(text) { const lineDiv = document.createElement('div'); lineDiv.className = 'console-output-line'; const segments = AnsiParser.parse(text); let currentClasses = []; for (const segment of segments) { if (segment.classes.includes("reset")) { currentClasses = []; continue; } currentClasses = [...currentClasses, ...segment.classes.filter(c => c)]; if(segment.text) { const span = document.createElement('span'); span.textContent = segment.text; span.className = [...new Set(currentClasses)].join(' '); lineDiv.appendChild(span); } } return lineDiv; }
            trimOldLines() { while (this.lines.length > this.maxLines) { const oldLine = this.lines.shift(); oldLine?.parentNode?.removeChild(oldLine); } }
            scrollToBottomIfNeeded() { if (this.isAtBottom) { this.container.scrollTop = this.container.scrollHeight; } }
        }

        class AppController {
            constructor() {
                this.session = { id: null, type: null };
                this.logPollIntervalId = null;
                this.console = new VirtualConsole("output-container");
                this.commandHandler = new CommandHandler("command-input", this.console, this.sendCommand.bind(this));
                this.ui = { 
                    modal: document.getElementById("start-modal-backdrop"), 
                    modalInitialState: document.getElementById("modal-initial-state"),
                    modalLoadingState: document.getElementById("modal-loading-state"),
                    containerTypeSelect: document.getElementById("container-type-select"),
                    startButton: document.getElementById("start-session-button"), 
                    consoleContainer: document.getElementById("console-container"), 
                    commandInput: document.getElementById("command-input") 
                };
                this.ui.startButton.addEventListener("click", this.startNewSession.bind(this));
            }

            init() {
                const params = new URLSearchParams(window.location.search);
                const sessionId = params.get("session");
                const sessionType = params.get("type");

                if (sessionId && sessionType) {
                    this.resumeSession(sessionId, sessionType);
                } else {
                    this.ui.modal.classList.remove("hidden");
                    this.ui.modal.querySelector("div").classList.remove("scale-95");
                }
            }
            
            async startSession(sessionId, sessionType) {
                this.session = { id: sessionId, type: sessionType };
                this.updateUrl();
                this.ui.modal.classList.add("hidden");
                this.ui.consoleContainer.classList.remove("hidden");
                this.ui.commandInput.disabled = false;
                this.ui.commandInput.focus();
                this.startLogPolling();
            }

            async resumeSession(sessionId, sessionType) {
                this.console.addLine(`\u001b[33mRestoring session (${sessionType})...\u001b[0m`);
                await this.fetchHistory();
                await this.startSession(sessionId, sessionType);
            }

            async startNewSession() {
                this.ui.modalInitialState.classList.add("hidden");
                this.ui.modalLoadingState.classList.remove("hidden");
                
                const sessionType = this.ui.containerTypeSelect.value;

                try {
                    const response = await fetch(`/api/start?type=${sessionType}`, { method: "POST" });
                    if (!response.ok) throw new Error(`Server error: ${response.statusText}`);
                    const { sessionId } = await response.json();
                    this.console.addLine(`\u001b[90mSession ID created: ${sessionId}\u001b[0m`);
                    this.beginHealthCheck(sessionId, sessionType);
                } catch (error) {
                    this.console.addLine(`\u001b[31mError starting session: ${error.message}\u001b[0m`);
                    this.ui.modalInitialState.classList.remove("hidden");
                    this.ui.modalLoadingState.classList.add("hidden");
                }
            }
            
            beginHealthCheck(sessionId, sessionType) {
                let attempts = 0;
                const maxAttempts = 30;
                const pollDelay = 2000;

                this.console.addLine(`\u001b[33mPinging container (${sessionType}) for readiness...\u001b[0m`);

                const poll = async () => {
                    if (attempts >= maxAttempts) {
                        this.console.addLine(`\u001b[31mContainer failed to respond after ${maxAttempts * (pollDelay/1000)} seconds. Please try again.\u001b[0m`);
                        this.ui.modalInitialState.classList.remove("hidden");
                        this.ui.modalLoadingState.classList.add("hidden");
                        return;
                    }

                    attempts++;
                    try {
                        const response = await fetch(`/api/health?session=${sessionId}&type=${sessionType}`);
                        if (response.ok) {
                            this.console.addLine("\u001b[32mContainer is ready. Connecting...\u001b[0m");
                            await this.startSession(sessionId, sessionType);
                            return;
                        }
                    } catch (error) {
                        console.warn(`Health check attempt ${attempts} failed, will retry...`);
                    }

                    // If not successful, schedule the next poll.
                    setTimeout(poll, pollDelay);
                };

                // Start the first poll
                poll();
            }

            updateUrl() {
                if (!this.session.id || !this.session.type) return;
                const url = new URL(window.location.href);
                url.searchParams.set("session", this.session.id);
                url.searchParams.set("type", this.session.type);
                window.history.pushState({ ...this.session }, "", url.toString());
            }

            startLogPolling() {
                if (this.logPollIntervalId) clearInterval(this.logPollIntervalId);
                
                const poll = async () => {
                    if (!this.session.id) return;
                    try {
                        const response = await fetch(`/api/logs?session=${this.session.id}&type=${this.session.type}`);
                        if (!response.ok) {
                            if (response.status >= 400 && response.status < 500) {
                                this.console.addLine(`\u001b[31mSession polling failed: ${response.statusText}. Please refresh.\u001b[0m`);
                                this.stopLogPolling();
                            }
                            return;
                        }
                        const text = await response.text();
                        if (text) this.console.addLines(text.trimEnd().split('\n'));
                    } catch (error) {
                        console.error("Polling error:", error);
                        this.console.addLine(`\u001b[91mNetwork error while polling logs.\u001b[0m`);
                    }
                };
                
                this.logPollIntervalId = setInterval(poll, 2500);
            }

            stopLogPolling() {
                clearInterval(this.logPollIntervalId);
                this.logPollIntervalId = null;
                this.ui.commandInput.disabled = true;
            }

            async fetchHistory() {
                 if (!this.session.id) return;
                 try {
                     const response = await fetch(`/api/history?session=${this.session.id}`);
                     if (!response.ok) throw new Error(`Could not fetch session history: ${response.statusText}`);
                     const text = await response.text();
                     if (text) {
                        this.console.addLines(text.trimEnd().split('\n'));
                        this.console.addLine("\u001b[90m--- End of stored history --- \u001b[0m");
                     }
                } catch(error) {
                    this.console.addLine(`\u001b[31mError fetching history: ${error.message}\u001b[0m`);
                }
            }
            
            async sendCommand(command) {
                if (!this.session.id) return;
                this.console.addLine(`\u001b[92m> ${command}\u001b[0m`);
                try {
                    await fetch(`/api/command?session=${this.session.id}&type=${this.session.type}`, { method: "POST", headers: { "Content-Type": "text/plain" }, body: command });
                } catch (error) {
                    this.console.addLine(`\u001b[31mFailed to send command: ${error.message}\u001b[0m`);
                }
            }
        }

        class CommandHandler {
            constructor(inputId, console, commandCallback) {
                this.input = document.getElementById(inputId); this.history = []; this.historyIndex = -1; this.commandCallback = commandCallback;
                this.input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter" && this.input.value.trim() !== "") {
                        const command = this.input.value; this.history.unshift(command);
                        if (this.history.length > 50) this.history.pop();
                        this.commandCallback(command); this.input.value = ""; this.historyIndex = -1;
                    } else if (e.key === "ArrowUp") {
                        e.preventDefault();
                        if (this.history.length > 0 && this.historyIndex < this.history.length - 1) { this.historyIndex++; this.input.value = this.history[this.historyIndex]; }
                    } else if (e.key === "ArrowDown") {
                         e.preventDefault();
                         if (this.historyIndex > 0) { this.historyIndex--; this.input.value = this.history[this.historyIndex]; } else { this.historyIndex = -1; this.input.value = ""; }
                    }
                });
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            const app = new AppController();
            app.init();
        });
    </script>
</body>
</html>

